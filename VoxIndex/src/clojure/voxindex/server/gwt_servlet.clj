#_ ( Copyright (c) 2011 - 2014 Howard Green. All rights reserved.
                
     The use and distribution terms for this software are covered by the
     Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
     which can be found in the file epl-v10.html at the root of this distribution.
     By using this software in any fashion, you are agreeing to be bound by
     the terms of this license.
     
     You must not remove this notice, or any other, from this software.
     )
#_ (* Provides an app-server servlet that interacts with a VoxIndex client via Google 
      Windows Toolkit's form of RPC. 
      )
(ns voxindex.server.gwt-servlet
  (:import
    [voxindex.shared LookupResult LookupResult$Indexable 
     VocalIndexItem VoxIndexService RootEntry 
     IndexContent IndexContent$IndexEntry IndexContent$IndexSpec
     LoginRequiredException AuthenticationException]
    ; [voxindex.server ConfigWrapper]
    [java.util Date]
    [java.io FileOutputStream ]
    [javax.servlet ServletContextListener ServletContextEvent ServletContext]
    [com.mongodb Mongo]
    [com.google.gwt.user.server.rpc RemoteServiceServlet]
    )
  (:use
    [indexterous.config.assigned-ids]
    [indexterous.index.index]
    [indexterous.index.db]
    [indexterous.index.document]
    [voxindex.vshell.recognizer-base]
    [voxindex.vshell.recognizer]
    [voxindex.vshell.control-grammar]
    [voxindex.server.vox-log]
    [voxindex.server.infrastructure]
    [voxindex.server.service-environment]
    )
  (:require 
    [voxindex.server.vox-server-params :as params])
  )

(def ^{:private true} listener-id "VoxIndexListener")


(defmacro defproxy [id base-class if-vec arg-vec  & body]
  (let [basis-vec (vec (concat [base-class] if-vec))
        make-fn (symbol (str "make-" id))]
    `(defn ~make-fn [] 
       (proxy ~basis-vec ~arg-vec
         ~@body)) 
   ))



#_ (* Creates a @(il javax.servlet.ServletContextListener) in support of 
      the VoxIndex servlet.
      )
(defproxy VoxIndexListener ServletContextListener [] [] 
  (contextInitialized [event]
      (try
        (let [context (.getServletContext event)
              mongo (Mongo.)]
          (log-info listener-id "Initializing, using " 
            (System/identityHashCode mongo) " " (.getDatabaseNames mongo))
          (.setAttribute context params/db-connection mongo))
        (catch Throwable t
          (log-error listener-id t "Exception during initialization: ")(.getMessage t))))
    
    (contextDestroyed [event] 
      (let [context (.getServletContext event)
            mongo (.getAttribute context params/db-connection)] 
        (log-info listener-id "Shutting down " (System/identityHashCode mongo))
        (if mongo (.close mongo)))))

(def ^{:private true} log-id "VoxIndexServlet")

#_ (* Constructs a list of (uri, source ID, locator-key) pairs for use in looking
      up a link URI during the bottom-up context recovery process.
      @arg db The database to use.
      @arg env A @(il ServiceEnvironment) object descrining the local service environment.
      @(returns A list whose elements are tuples of the form 
                @(form [service-uri source-id locator-key]), where
                @arg service-uri A base service URI
                @arg source-id The object ID of the source that contains @(arg service-uri)
                as a locator.
                @arg locator-key The locator key for @(arg service-uri) within the 
                source denoted by @(arg source-id).)
      )
(defn make-source-uri-list [db env]
  (let [sources (fetch-all db (source-collection db))]
    (reduce 
      (fn [uri-tuples+ source]
        (let [uri-tuples (mapped-source-uris env source false)] 
          #_(println "m-s-uri: " source " = " uri)
          (concat uri-tuples+ uri-tuples)))
      '() sources)))

;#_ (* Given a URI and a list of uri-tuples as generated by @(l make-source-uri-list),
;     looks for a uri-tuple that has a URI matching matches the start of the given URI.
;     @arg source-list A list of tuples as generated by @(l make-source-uri-list).
;     @arg uri A targt URI to look for.
;     @(returns A tuple of the form @(form [source-id locator-key relative-uri]),
;        where 
;        @arg source-id THe object ID of a source.
;        @arg locator-key The key of a locator within the source.
;        @arg relative-uri The portion of the target URI not subsumed by the
;        locator at @(arg locator-key) within @(arg source-id).)
;     )
;(defn uri-source [source-list uri]
;  (let [[source-uri source-id locator-key] 
;        (some (fn [[source-uri source-id locator-key :as tuple]]
;                (if (or(= source-uri uri) tuple
;                      (and (.startsWith uri source-uri)
;                        (get #{\/ \? \# } (.charAt uri (count source-uri))))) 
;                  tuple)) 
;              source-list)]
;    (if source-id
;      (let [[_ rel-uri] (subs uri (.length source-uri))]
;        [source-id locator-key rel-uri]))))
;

#_ (* Given a URI, finds an indexable that has that URI.
     @p This implies that we have a list of (source-id locator-id) pairs that,
     when evaluated, would match the initial portion of the URI
     @returns The indexable, if one was found, or nil otherwise.
     )
(defn uri-indexable [db source-list uri]
  (let [[source-id locator-key rel-uri] 
        #_( Given the URI and a list the uri-tuples as generated by make-source-uri-list,
            look for a uri-tuple that has a URI matching the start of the given URI.)
        (let [[locator-uri source-id locator-key] 
              (some (fn [[loc-uri src-id loc-key :as tuple]]
                      (if (or (= loc-uri uri) tuple
                            (and (.startsWith uri loc-uri)
                              (get #{\/ \? \# } (.charAt uri (count loc-uri))))) 
                        tuple)) 
                source-list)]
          (if source-id
            [source-id locator-key (subs uri (.length locator-uri))]))]
    (if source-id
      (let [indexable 
            (fetch-one db (indexable-collection db) 
              { "source-ref" source-id "locator-key" locator-key "relative-uri" rel-uri} )]
        indexable))))


#_ (* Processes a list of targets generated by the lookup process into an
      array of @(link voxindex.shared.LookupResult$Indexable LookupResult.Indexable)
      objects suitable for return to a client.
      @arg targets A collection of @(il voxindex.vshell.recognizer-base.RecognizedTarget)
      objects as returned by the recognizer
      )
(defn indexable-targets [targets env]
  (let [indexable-thingies 
        (map 
          (fn [target] 
            (let [indexable (indexable-of target)
                  source (indexable-source-of target)
                  conids (conids-of target)
                  indexable-thingy 
                  (LookupResult$Indexable. 
                    (cond 
                      (satisfies? SuperTitled indexable) (supertitle-of indexable)
                      (satisfies? Titled indexable) (title-of indexable)
                      (satisfies? Named indexable) (name-of indexable)
                      :else "")
                    (if source
                      (description-of source)
                      "")
                    (mapped-uri env source indexable false)
                    (java.util.HashSet. (set conids)))]
              indexable-thingy
              ))
          targets)]
    (into-array LookupResult$Indexable indexable-thingies)))


#_ (* Fulfills an indexContent request by building an array of
      horrificly huge @(link IndexContent) objects that represent
      the contents of a sequence of index IDs.)
(defn index-contents [db iids]
  (try
    (let [indexes (fetch db (index-collection db) 
                         { "_id" { "$in" (vec (map oid iids))}})]
      (into-array IndexContent
        (map 
          (fn [index] 
            ;(println "Index " (id-string-of index))
            (IndexContent. 
              (name-of index) (description-of index)
              (into-array IndexContent$IndexSpec
                (map 
                  (fn [[category prefixes entries]]
                    ;(println "--- spec " prefixes)
                    (IndexContent$IndexSpec. 
                      category 
                      (if prefixes 
                        (into-array String 
                          (if (string? prefixes) [prefixes] prefixes)) 
                        nil)
                      (into-array IndexContent$IndexEntry
                        (map 
                          (fn [[source-term indexable-ref term-or-terms]]
                            ;(println "--- --- entry " source-term)
                            (IndexContent$IndexEntry. 
                              source-term
                              (into-array String 
                                          (if (string? term-or-terms)
                                            [term-or-terms] 
                                            term-or-terms))))
                          entries))))
                  (specs-of index))))) 
          indexes)))
    (catch Throwable t
      (log-error log-id t "Exception during indexContent:" (.getMessage t))
      (.printStackTrace t)
      (throw t))))

(defn servlet-request [servlet] (.getThreadLocalRequest servlet) )
(defn servlet-response [servlet] (.getThreadLocalResponse servlet) )
(defn servlet-context [servlet] (.getServletContext servlet))

(defn mongo-identity [mongo]
  (apply str (interpose "," (map  #(.toString (.getSocketAddress %)) (.getServerAddressList mongo)))))

(defonce last-rec* (ref nil))
(defonce last-result* (ref nil))
(defonce last-env* (ref nil))

#_ (* Constructs a servlet for voice recognition over indexes using GWT RPC as 
      the underlying protocol.
      @arg env A @(il ServiceEnvironment) object describing the server environment.
      @returns The servlet.
      )
(defn make-VoxIndexServlet [env]
  (proxy [RemoteServiceServlet VoxIndexService] []
	  (square [n]
	    (let [nn (int (* n n))]
	        (println "Proxied Square of" n "is" nn)
	        nn))
	    
	  (login [userid credentials session-id]
     (log-info log-id "GWT Login by " userid (if session-id (str " with " session-id)) )
     (try
       ;; If login contains a session ID, see if it's still valid, and just return
       ;; it if it is. Otherwise, it's time for full authentication and a new session.
       (if (and session-id 
             (let [session (get-session session-id)]
               #_(println "----" 
                  (if session 
                    (str " user " (user-id-of (user-of session)) " exp " (expired? session))
                    " no session")) 
               (and session (= (user-id-of (user-of session)) userid) (not (expired? session)))))
         (do
           (log-info log-id "Login reusing " session-id)
           session-id)
         (if-let [user (authenticate-user userid credentials)]
           (let [mongo (.getAttribute (servlet-context this) params/db-connection)
	                db-name (user-db-name-of user)
	                db (new-IndexterousDB mongo db-name)
	                recognizer (new-Recognizer db env)
	                session (new-Session user db recognizer)
	                ]
	            (activate-session session)
	            (log-info log-id 
	                    (str "Opening DB " db-name " in server " (mongo-identity mongo) 
                       " using " (System/identityHashCode mongo)  "\n"))
	            (open-db db)
	            (start recognizer)
	            (log-info log-id "Login OK " userid " session " (session-id-of session)
	                      " using DB " db-name " at server " (mongo-identity mongo))
	            (session-id-of session))
           (throw (AuthenticationException. "Unrecognized user/password"))))
	      (catch Throwable t 
	          (log-error log-id t "Exception during login: " (.getMessage t))
	          #_(.printStackTrace t)
           (throw (AuthenticationException. "Exception during login"))))
	      ) ;; login
	    
	  (logout [session-id]
		    (log-info log-id "GWT Logout for" session-id)
	      (try
	        (if-let [session (get-session session-id)]
	          (terminate (recognizer-of session)))
	        (terminate-session session-id)
	        (catch Throwable t 
	          (log-error log-id t "Exception during logout: " (.getMessage t))
	          (.printStackTrace t)))
	      ) ;; logout
   
;   (loginCheck [user-id session-id]
;     (log-info log-id "GWT login verify for" user-id "/" session-id)
;     (let [session (get-session session-id)]
;       (and session (= (user-of session) user-id) (not (expired? session)))))
	    
	  (voxLookup [session-id client-tag index-ids wave-data]
      (log-info log-id "GWT VoxLookup session: " session-id " " "tag:" client-tag " " (count wave-data) " bytes" )
      (if-let [session (get-session session-id)]
	       (try
           (do
             (session-requested session wave-data)
             (let [result-promise (promise)]
               (log-debug log-id "starting recognition...")
	             (wave-recognize (recognizer-of session) index-ids wave-data 
	                             (fn [result] (deliver result-promise result)))
              (let [result @result-promise
                    _ (log-debug log-id "...got result")

                    lookup-result 
                    (LookupResult. 
                      client-tag
                      (recognized? result)
                      (sub-threshold? result)
                      (confidence-of result)
                      (index-name-of result)
                      (phrase-of result)
                      (command-of result)
                      (indexable-targets (targets-of result) env)
                      ; (html-grammary (get-vshell this))
                      )
                    ]
                (dosync ;;; XXX XXXXXX XXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXS
                  (ref-set last-rec* result) 
                  (ref-set last-env* env)
                  (ref-set last-result* lookup-result))
                lookup-result
                )))
	         (catch Throwable t 
	           (log-error log-id t "Exception during voxLookup: " (.getMessage t))
	           (.printStackTrace t)))
	       (do 
	         (log-error log-id "GWT VoxLookup no session " session-id)
	         (throw (LoginRequiredException. "Login required"))))
	      ) ;; voxLookup 
	    
	  (indexLookup [session-id client-tag index-ids]
	    (if-let [session (get-session session-id)]
	      (try
	        (do
	          (log-info log-id "invocation of indexLookup by " client-tag " for " index-ids)
	          (LookupResult. 
	            client-tag
	            true
	            false
	            1.0
	            "Index"
	            "show index"
	            (str "urn:indexterous.audiology-command:index:"
	                 (service-index-service-uri env)
	                 (if-not (empty? index-ids)  
	                   (apply str "?index=" (interpose "," index-ids) )))
	            (into-array LookupResult$Indexable [])))
	        (catch Throwable t 
	          (log-error log-id t "Exception during indexLookup:" (.getMessage t))
	          (.printStackTrace t)))
	      (do 
	        (log-error log-id "GWT indexLookup no session " session-id)
	        (throw (LoginRequiredException. "Login required"))))
	    ) ;; indexLookup
	    
     #_ (* This is kinda sorta the inverse of the normal lookup mechanism, where
          we look up an indexable relative to some context. Here, we're given a
          URI, generally relative to some existing context, and we want to determine
          what indexable that URI represents, and what an appropriate context for that
          indexable would be.
          @p It's slightly lame, but kinda sorta makes sense in the Android client,
          where a user can navigate not only with voice but by poking links, too...
          and it's that latter case that makes life exciting.
          )
	  (linkLookup [session-id client-tag index-ids link-uri]
	    (if-let [session (get-session session-id)]
	      (try
	        (do
	          (log-info log-id "invocation of linkLookup by " client-tag " for " link-uri)
	          (let [db (session-db-of session)
	                uri-list (make-source-uri-list db env)
	                indexable (uri-indexable db uri-list link-uri)]
	            (if (and indexable 
	                     (satisfies? Parented indexable) 
	                     (parent-ids-of indexable))
	              (let [p-ids (.split (parent-ids-of indexable) ",")
                     xindexid (reduce (fn [s+ s] (if (< (count s) (count s+)) s s+)) p-ids)
                     
                     _ (log-info log-id "######### indexable: " (id-string-of indexable) 
	                                " p-ids: " p-ids " xindexid: " xindexid)
                     index (fetch-index db (oid xindexid))
	                   source (fetch-source db (source-ref-of indexable))]
	                
	                (LookupResult.
	                  client-tag
	                  true
	                  false
	                  1.0
	                  (if index (name-of index) "")
	                  "<link>"
	                  nil
	                  (into-array LookupResult$Indexable 
	                              [(LookupResult$Indexable. 
	                                 (cond 
	                                   (satisfies? SuperTitled indexable) (supertitle-of indexable)
	                                   (satisfies? Titled indexable) (title-of indexable)
	                                   (satisfies? Named indexable) (name-of indexable)
	                                   :else "")
	                                 (if source (description-of source) "")
	                                 link-uri
	                                 (java.util.HashSet.
	                                   (conj (set p-ids) 
	                                         control-index-id audiology-index-id)))]))))))
	        (catch Throwable t 
	          (log-error log-id t "Exception during linkLookup:" (.getMessage t))
	          (.printStackTrace t)))
	      (do 
	        (log-error log-id "GWT linkLookup no session " session-id)
	        (throw (LoginRequiredException. "Login required")))))
	        
	  (rootEntries [session-id]
	    (if-let [session (get-session session-id)]
	      (do
	        (log-info log-id "invocation of rootEntries")
	        (let [db (session-db-of session)
	              res 
	              (reduce 
	                (fn [res+ re]
	                  (conj res+ (RootEntry. (description-of re) 
	                                         (into-array String (root-terms-of re)))))
	                [] 
	                (sort-by (fn [re] (description-of re) ) 
	                         (fetch-all db (root-collection db))))]
	          (into-array RootEntry res)))
	      (do 
	        (log-error log-id "GWT rootEntries no session " session-id)
	        (throw (LoginRequiredException. "Login required"))))
	    ) ; rootEntries
	  
	  (indexContent [session-id iids]
	    (if-let [session (get-session session-id)]
	      (do
	        (log-info log-id (apply str "invocation of indexContent: " iids))
	        (index-contents (session-db-of session) iids))
	      (throw (LoginRequiredException. "Login required"))))
	        
	  (refresh [session-id]
	    (if-let [session (get-session session-id)]
	      (let [recognizer (recognizer-of session)
	            cgrammar (new-ControlGrammar recognizer)]
	        (refresh-grammar recognizer cgrammar))
	      (throw (LoginRequiredException. "Login required")))))
  ) ;; VoxIndexServlet



